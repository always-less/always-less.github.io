<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Java," />










<meta name="description" content="可以说lambda和stream api彻底改变了Java程序员的代码风格及编程思想，它可以让你用声明性的方式处理数据集，用函数式的思维分析问题，并能够很轻易地并行处理数据。本篇将详细讲解stream api是如何实现这些强大的功能。">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 8 Stream Api的一点研究">
<meta property="og:url" content="https://always-less.github.io/2017/java-8-stream/index.html">
<meta property="og:site_name" content="张冲的博客">
<meta property="og:description" content="可以说lambda和stream api彻底改变了Java程序员的代码风格及编程思想，它可以让你用声明性的方式处理数据集，用函数式的思维分析问题，并能够很轻易地并行处理数据。本篇将详细讲解stream api是如何实现这些强大的功能。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://always-less.github.io/images/java-8-stream/stream.PNG">
<meta property="og:image" content="https://always-less.github.io/images/java-8-stream/fork-join-task.PNG">
<meta property="og:image" content="https://always-less.github.io/images/java-8-stream/fork-join-process.PNG">
<meta property="og:image" content="https://always-less.github.io/images/java-8-stream/parallel-stream.PNG">
<meta property="og:updated_time" content="2017-11-27T15:18:27.649Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 8 Stream Api的一点研究">
<meta name="twitter:description" content="可以说lambda和stream api彻底改变了Java程序员的代码风格及编程思想，它可以让你用声明性的方式处理数据集，用函数式的思维分析问题，并能够很轻易地并行处理数据。本篇将详细讲解stream api是如何实现这些强大的功能。">
<meta name="twitter:image" content="https://always-less.github.io/images/java-8-stream/stream.PNG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://always-less.github.io/2017/java-8-stream/"/>





  <title>Java 8 Stream Api的一点研究 | 张冲的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张冲的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://always-less.github.io/2017/java-8-stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张冲">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张冲的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java 8 Stream Api的一点研究</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-26T13:37:55+08:00">
                2017-11-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          
              <div class="post-description">
                  可以说lambda和stream api彻底改变了Java程序员的代码风格及编程思想，它可以让你用声明性的方式处理数据集，用函数式的思维分析问题，并能够很轻易地并行处理数据。本篇将详细讲解stream api是如何实现这些强大的功能。
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>集合是Java中使用最多的API，几乎每个Java应用程序都会涉及到集合的处理。Java提供了丰富而强大的集合框架，但在Java8之前，对于一些集合聚合操作的处理上仍然只能靠程序员自己去处理集合的遍历、过滤、组装和增删改的各种细节。对于熟悉命令式编程的程序员来说会觉得编程本该如此，将实际问题用计算机熟悉的方式编程解决，而问题恰恰在此。当你从一行行的处理细节中试图还原代码的真实意图时就能体会到，命令式的风格是计算机所擅长的方式而非人类所易于接受的思维。</p>
<p>看下Stream Api是如何解决这个问题的。</p>
<h1 id="告别for循环"><a href="#告别for循环" class="headerlink" title="告别for循环"></a>告别for循环</h1><p>举几个例子。</p>
<p>需求一：返回给定规则列表中规则优先级大于50的规则的名字列表。<br>实体类Rule<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Data</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rule</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 规则名称</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority;   <span class="comment">// 规则优先级</span></div><div class="line">    <span class="keyword">private</span> Action action;  <span class="comment">// 规则决策结果</span></div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Action &#123;</div><div class="line">        DENY, PASS</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Java8之前实现如下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getRuleNames</span><span class="params">(List&lt;Rule&gt; rules)</span> </span>&#123;</div><div class="line">    List&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">for</span> (Rule rule : rules) &#123;</div><div class="line">        <span class="keyword">if</span> (rule.getPriority() &gt; <span class="number">50</span>) &#123;</div><div class="line">            ret.add(rule.getName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用stream api实现如下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getRuleNamesByStream</span><span class="params">(List&lt;Rule&gt; rules)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> rules.stream()</div><div class="line">            .filter(rule -&gt; rule.getPriority() &gt; <span class="number">50</span>)</div><div class="line">            .map(Rule::getName)</div><div class="line">            .collect(Collectors.toList())</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然代码量差不多，但显然是两种不同的风格。下面的代码中，stream()函数用于将一个集合构造成一个流，然后filter()和map()函数分别定义了对于流里的每个元素的过滤和映射操作，collect()函数定义了流的终止操作，即将流里的每个元素收集到一个List中并返回。这里只直观感受两者区别，具体细节后面会展开分析。</p>
<p>如果你觉得也没看出stream api有多大优势，那么下面这两个例子肯定会改变你的想法。</p>
<p>需求二：对于给定的规则列表，跳过前10个（不要问为什么），然后在剩下的规则中返回优先级大于50的前100个规则的名字列表。<br>在Java8之前实现如下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getRuleNames</span><span class="params">(List&lt;Rule&gt; rules)</span> </span>&#123;</div><div class="line">    List&lt;String&gt; ret = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> skippedNum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Rule rule : rules) &#123;</div><div class="line">        <span class="keyword">if</span> (++skippedNum &gt;= <span class="number">10</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (rule.getPriority() &gt; <span class="number">50</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (++count &gt; <span class="number">100</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            ret.add(rule.getName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到虽然只是在第一个需求的基础上加了两个限制条件，但用命令式的方式要想bug-free的实现也还是要费一番工夫的。你可能需要仔细确认是要前缀++还是后缀++，该用&gt;还是&gt;=，应该在add前break还是应该在add后break。实际上这段代码不仅极为脆弱，且很难直观看出其意图。哪怕你知道需求，每次你看到这里的时候，可能都得再次确认是不是满足了需求。如果工程里全是这种代码，那维护的成本可想而知。</p>
<p>如果用stream api实现，则不能更简单，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getRuleNamesByStream</span><span class="params">(List&lt;Rule&gt; rules)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> rules.stream()</div><div class="line">            .skip(<span class="number">10</span>)</div><div class="line">            .filter(rule -&gt; rule.getPriority() &gt; <span class="number">50</span>)</div><div class="line">            .limit(<span class="number">100</span>)</div><div class="line">            .map(Rule::getName)</div><div class="line">            .collect(Collectors.toList())</div></pre></td></tr></table></figure></p>
<p>只需要“告诉”流需要先skip前10个规则，filter后在满足条件的规则中limit前100个，并把规则map成规则的名字collect到List中返回即可。几乎就是用代码把需求完整地复述了一遍，且stream api会帮你处理所有的底层细节。</p>
<p>需求三：在需求二的基础上，将返回的名字列表基于规则的Action分类返回。<br>在Java8之前实现如下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Map&lt;Rule.Action, List&lt;String&gt;&gt; getRuleNames(List&lt;Rule&gt; rules) &#123;</div><div class="line">    Map&lt;Rule.Action, List&lt;String&gt;&gt; ret = <span class="keyword">new</span> EnumMap&lt;&gt;(Rule.Action.class);</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> skippedNum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Rule rule : rules) &#123;</div><div class="line">        <span class="keyword">if</span> (++skippedNum &gt;= <span class="number">10</span>) &#123;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (count &gt; <span class="number">100</span>) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (rule.getPriority() &gt; <span class="number">50</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (ret.get(rule.getAction()) == <span class="keyword">null</span>) &#123;</div><div class="line">                ret.put(rule.getAction(), <span class="keyword">new</span> ArrayList&lt;&gt;());</div><div class="line">            &#125;</div><div class="line">            ret.get(rule.getAction()).add(rule.getName());</div><div class="line">            count++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用stream api实现如下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">public</span> Map&lt;Rule.Action, List&lt;String&gt;&gt; getRuleNamesByStream(List&lt;Rule&gt; rules) &#123;</div><div class="line">    <span class="keyword">return</span> rules.stream()</div><div class="line">            .skip(<span class="number">10</span>)</div><div class="line">            .filter(rule -&gt; rule.getPriority() &gt; <span class="number">50</span>)</div><div class="line">            .limit(<span class="number">100</span>)</div><div class="line">            .collect(groupingBy(Rule::getAction, mapping(Rule::getName, toList())));</div></pre></td></tr></table></figure></p>
<p>可以看到stream api可以用极为简单的方式实现类似Sql中group by的功能，而对于第一种方式应该也不用再吐槽了。</p>
<h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><p>从上面的三组例子可以看到，stream api对于集合的处理都基于流（stream）这一抽象概念。<br>当把这一切都准备好让你可以开箱即用时，你可能大呼过瘾的同时会感觉对集合的处理本该如此。但能从零到一想到这种抽象，且能“完美”结合Java已有的集合框架以及新特性lambda表达式构建出这一整套体系，不得不说还是很强大的，这里面的技术思想也很值得一探。</p>
<h2 id="流是什么"><a href="#流是什么" class="headerlink" title="流是什么"></a>流是什么</h2><p>流是stream api对集合处理所定义的一个抽象概念，它允许你以声明式的方式处理数据集合。可以简单理解成遍历数据集的一个高级的内部迭代器，区别于传统Java集合中需要程序员外部控制遍历的iterator。流只能遍历一次，且可以透明的并行处理。</p>
<p>下图可助于理解stream的概念及处理过程。</p>
<p><img src="/images/java-8-stream/stream.PNG" alt=""></p>
<p>几个关键问题，</p>
<ul>
<li><p>上图中的处理过程中共遍历几遍集合？</p>
<blockquote>
<p>一遍。具体的，是对每个元素先filter，如果符合条件再map成规则名，在判断如果当前数目小于3则加到待返回List中，如果等于3则加到List中返回，后面的元素不再遍历（短路）。</p>
</blockquote>
</li>
<li><p>filter、map、limit和collect有什么区别？</p>
<blockquote>
<p>流的操作分为两种类型，filter、map、limit这种为intermediate操作，而collect为terminal操作。intermediate操作定义了流上每个元素要执行的具体操作，且都是惰性的（不会触发流的遍历），而terminal操作会触发流的遍历，并把符合条件的元素加入到自定义的集合中返回。</p>
</blockquote>
</li>
<li><p>性能如何？</p>
<blockquote>
<p>可以预想由于引入了新的数据结构的构造执行流程，性能上肯定不如同等逻辑的自定义for循环的代码。但还是那个老生常谈的问题，0.00001比0.0001快10倍，但真的matter吗？另外后面会讲并行流如何处理数据，这意味着我们可以非常轻松地在多核的机器上并行处理数据以提升性能。</p>
</blockquote>
</li>
</ul>
<h2 id="流的使用"><a href="#流的使用" class="headerlink" title="流的使用"></a>流的使用</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>构造流的几种常见方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 自定义</span></div><div class="line">Stream stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</div><div class="line">IntStream intStream = IntStream.range(<span class="number">0</span>, <span class="number">3</span>);    <span class="comment">// 0, 1, 2</span></div><div class="line">intStream = IntStream.rangeClosed(<span class="number">0</span>, <span class="number">3</span>)         <span class="comment">// 0, 1, 2, 3</span></div><div class="line">intStream = IntStream.iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>);   <span class="comment">// 递增的无穷大序列</span></div><div class="line"></div><div class="line"><span class="comment">// 2. 数组</span></div><div class="line">String[] strArr = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</div><div class="line">stream = Stream.of(strArr);</div><div class="line">stream = Arrays.stream(strArr);</div><div class="line"></div><div class="line"><span class="comment">// 3. 集合</span></div><div class="line">List&lt;Rule&gt; ruleList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">stream = ruleList.stream();</div></pre></td></tr></table></figure></p>
<p>需注意，对于基本类型，目前有三种对应的包装类型Stream：IntStream、LongStream、DoubleStream。这主要是考虑到数值类型集合运算的效率（不用boxing成对象类型和unboxing成基本类型），且数值类型流会有很多类似sum()、average()这种一般对象流中不会定义的终止操作。</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>得到一个流后，便可以对流中的元素进行各种操作以返回我们想要的结果。常用的操作归类如下，</p>
<ul>
<li><p>Intermediate</p>
<blockquote>
<p>map、mapToInt、mapToLong、mapToDouble、flatMap、filter、distinc、sorted、skip、limit、peek、parallel、sequential</p>
</blockquote>
</li>
<li><p>Terminal</p>
<blockquote>
<p>forEach、collect、reduce、min、max、count、anyMatch、allMatch、noneMatch、findFirst、findAny</p>
</blockquote>
</li>
<li><p>Short-circuiting</p>
<blockquote>
<p>anyMatch、allMatch、noneMatch、findFirst、findAny、limit</p>
</blockquote>
</li>
</ul>
<p>具体使用方式可见jdk文档的注释。熟能生巧。</p>
<h1 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h1><p>在Java7之前，并行处理数据集合非常麻烦。第一，你得明确地把包含数据的数据结构分成若干子部分。第二，你要给每个子部分分配一个独立的线程。第三，你要在恰当的时候对它们进行同步来避免不希望出现的竞争条件，等待所有线程完成，最后把这些结果合并起来。Java7引入了Fork/Join框架，让这些操作更稳定且不易出错，但Fork/Join框架的使用仍然较为繁琐。现在，stream api也使用了Fork/Join框架，但封装了底层细节使你可以很轻易得实现数据集合的并行处理。当然要想正确使用，你仍需了解流内部是如何工作的。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>假设你需要计算一个巨型的int数组的和(假定不用考虑溢出的问题)，如下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Arrays.stream(arr)</div><div class="line">            .reduce(<span class="number">0</span>, Integer::sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码等价于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</div><div class="line">        result += arr[i];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果想要并行处理的话，只需要<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Arrays.stream(arr)</div><div class="line">            .parallel()     <span class="comment">// 将流转换为并行流</span></div><div class="line">            .reduce(<span class="number">0</span>, Integer::sum);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如此，stream api会帮你搞定所有的并行处理的细节，包括数据集合的划分、线程的创建、任务的分配、结果的合并。</p>
<blockquote>
<p>如果想要使并行流变成顺序流只需调用sequential即可。两种调用不意味着流本身有任何实际的变化，其内部实现上只是设置了一个boolean标志，表示你所构造的流是并行流还是顺序流。就是说如下所示调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stream.parallel()</div><div class="line">      .filter(...)</div><div class="line">      .sequential()</div><div class="line">      .map(...)</div><div class="line">      .parallel()</div><div class="line">      .reduce(...);</div></pre></td></tr></table></figure></p>
<p>并不会并行执行filter、reduce操作而顺序执行map操作。最后一次parallel调用会使得整个流为并行流，且流上定义的所有操作都会并行执行</p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h3><p>Fork/Join框架的目的是以递归的方式将可以并行的任务拆分成更小的任务，然后将每个子任务的结果合并起来生成整体结果。它是ExecutorService接口的一个实现，把子任务分配给线程池（ForkJoinPool）中的工作线程。</p>
<h4 id="定义任务"><a href="#定义任务" class="headerlink" title="定义任务"></a>定义任务</h4><p>要把任务提交到ForkJoinPool，必须创建RecursiveTask<r>的一个子类，其中R是并行化任务（以及所有的子任务）产生的结果类型，或者如果任务不返回结果，则是RecursiveAction类型。要定义RecursiveTask，只需实现它唯一的抽象方法compute，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> R <span class="title">compute</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></r></p>
<p>这个方法同时定义了将任务拆分成子任务的逻辑，以及无法拆分或不方便拆分时，生成单个子任务结果的逻辑。方法实现的伪代码大致如下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (任务足够小或不可分) &#123;</div><div class="line">    顺序计算该任务</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    将任务分成两个子任务</div><div class="line">    递归调用本方法，拆分每个子任务，等待所有子任务完成</div><div class="line">    合并每个子任务的结果</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般来说没有确切的标准决定一个任务是否应该再拆分，但有几种试探方法可以参考，下面会提到。递归任务拆分过程如下所示，<br><img src="/images/java-8-stream/fork-join-task.PNG" alt=""></p>
<p>用前面int数组求和的例子，定义ForkJoinSumCalculator任务如下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinSumCalculator</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] numbers;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">10_000</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculator</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>(numbers, <span class="number">0</span>, numbers.length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ForkJoinSumCalculator</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.numbers = numbers;</div><div class="line">        <span class="keyword">this</span>.start = start;</div><div class="line">        <span class="keyword">this</span>.end = end;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> length = end - start;</div><div class="line">        <span class="keyword">if</span> (length &lt;= THRESHOLD) &#123;</div><div class="line">            <span class="keyword">return</span> computeSequentially();</div><div class="line">        &#125;</div><div class="line">        ForkJoinSumCalculator leftTask = </div><div class="line">                <span class="keyword">new</span> ForkJoinSumCalculator(numbers, start, start + length / <span class="number">2</span>);</div><div class="line">        leftTask.fork();    <span class="comment">// 利用另一个ForkJoinPool线程异步执行新创建的子任务</span></div><div class="line">        ForkJoinSumCalculator rightTask = </div><div class="line">                <span class="keyword">new</span> ForkJoinSumCalculator(numbers, start + length / <span class="number">2</span>, end);</div><div class="line">        <span class="keyword">int</span> rightResult = rightTask.compute();  <span class="comment">// 同步执行第二个子任务，有可能进一步递归划分</span></div><div class="line">        <span class="keyword">int</span> leftResult = leftTask.join();       <span class="comment">// 读取第一个子任务结果，如果未完成就等待</span></div><div class="line">        <span class="keyword">return</span> leftResult + rightResult;    </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">computeSequentially</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</div><div class="line">            sum += numbers[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> sum;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h4><p>如此再计算数组求和就比较简单了，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkJoinSum</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</div><div class="line">    ForkJoinTask&lt;Integer&gt; task = <span class="keyword">new</span> ForkJoinSumCalculator(numbers);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool().invoke(task);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实际应用中，使用多个ForkJoinPool是没有意义的，一般将其构造成单例重用。<br>本例中的计算过程如下，<br><img src="/images/java-8-stream/fork-join-process.PNG" alt=""></p>
<h4 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a>工作窃取</h4><p>上例中在数组不多于10000个项目时就不再创建子任务了，这个选择是很随意的，但大多数情况下也很难找到一个好的启发式方法来确认它。如果有一个有1000万长度的数组，意味着ForkJoinSumCalculator会至少分出1000个子任务，对于多数计算机来说，似乎有点浪费资源，但分出大量的小任务一般来说都是一个好的选择。这是因为理想情况下，划分并行任务是应该让每个子任务都用完全相同的时间完成，让所有CPU内核都同样繁忙。但实际中，每个子任务所花的时间可能天差地别，要么因为划分策略效率低，或者其它不可预知的原因，如磁盘访问慢或者外部网络调用等。<br>Fork/Join框架的实现用work stealing（工作窃取）的技术来解决这个问题。在实际应用中，这意味着这些任务差不多被平均分配到ForkJoinPool的所有线程上，每个线程都为分配给它的任务保存一个双向链式队列，每完成一个任务就会从队列头取下一个任务开始执行。基于前面所述的原因，某个线程可能早早完成了分配给它的所有任务，也就是它的队列已经空了，而其他线程还很忙。这时这个线程会随机从一个别的线程的队列尾部“偷走”一个任务。这个过程一直持续下去，直到所有的任务都执行完毕。</p>
<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><p>虽然Fork/Join框架还算简单易用，但它也很容易被误用。以下是几个有效使用它的最佳实践，</p>
<ul>
<li>对一个任务调用Join方法会阻塞调用方，直到该任务作出结果。因此，有必要在两个子任务的计算都开始之后再调用join。</li>
<li>不应该在RecursiveTask内部使用ForkJoinPool的invoke方法。</li>
<li>对子任务调用fork方法可以把它排进ForkJoinPool，且一般对左右任务中一个任务fork，另一个复用当前线程直接compute，避免左右两边的子任务都调用fork而多分配一个任务。</li>
<li>多核处理器上使用Fork/Join框架并不一定比顺序计算快。要考虑问题的规模，分析一个任务是否可以分解成独立的子任务并进行合并，同时也要注意多线程编程的问题，如共享变量的访问等。</li>
<li>由于工作窃取机制的使用，控制任务分解的条件以能够分解出大量的小任务通常来说都是一个好的选择。</li>
</ul>
<h3 id="Spliterator"><a href="#Spliterator" class="headerlink" title="Spliterator"></a>Spliterator</h3><p>回到前面所述的并行流计算数组和的例子，其执行过程大致如下图所示，<br><img src="/images/java-8-stream/parallel-stream.PNG" alt=""></p>
<p>可以看到整个过程就是利用Fork/Join框架不断切分子任务，交由ForkJoinPool里的线程处理，然后规约合并。但是我们的代码中并没有定义如何划分子任务的逻辑，这说明肯定有一种自动机制来帮我们做了流的拆分。这个新机制就是Spliterator。</p>
<p>Spliterator是Java8中加入的一个新接口，是为了可以并行遍历数据源中的元素而设计的。Spliterator接口定义如下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Spliterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</div><div class="line">    <span class="function">Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，T为Spliterator遍历的元素的类型。tryAdvance方法的行为类似于普通的Iterator，因为它会按顺序一个一个使用Spliterator中的元素，如果还有其他元素要遍历就返回true。trySplit是专为Spliterator接口设计，它可以把一些元素划分出去分给第二个Spliterator（由该方法返回），让它们两个并行处理。Spliterator还可以通过estimateSize()方法估计还剩下多少元素需要遍历，因为即使不那么确切，能快速算出来是一个值也有助于让拆分均匀一点。</p>
<p>将Stream拆分成多个部分的算法是一个递归过程，类似Fork/Join框架中RecursiveTask的拆分，Spliterator调用trySplit方法生成第二个Spliterator，然后对这两个Spliterator调用trySplit，如此直到它返回null，表明其所处理的数据结构不能再分割。这个拆分过程也受Spliterator本身的特性影响，而特性是通过characteristics方法声明的。Spliterator的特性如下表所示，</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td>ORDERED</td>
<td>元素由既定的顺序（例如List），因此Spliterator在遍历和划分时也会遵循这一顺序</td>
</tr>
<tr>
<td>DISTINCT</td>
<td>对于任意一对遍历过的元素x和y，x.equals(y)返回false</td>
</tr>
<tr>
<td>SORTED</td>
<td>遍历的元素按照一个预定义的顺序排序</td>
</tr>
<tr>
<td>SIZED</td>
<td>该Spliterator由一个已知大小的源建立（例如Set），因此estimateSize()返回的是准确值</td>
</tr>
<tr>
<td>NONNULL</td>
<td>保证遍历的元素不会为null</td>
</tr>
<tr>
<td>IMMUTABLE</td>
<td>Spliterator的数据源不能修改。这意味着在遍历时不能添加、删除或修改任何元素</td>
</tr>
<tr>
<td>CONCURRENT</td>
<td>该Spliterator的数据源可以被其他线程同时修改而无需同步</td>
</tr>
<tr>
<td>SUBSIZED</td>
<td>该Spliterator和所有从它拆分出来的Spliterator都是SIZED</td>
</tr>
</tbody>
</table>
<p>默认情况下，Spliterator由框架提供，且流的数据源的结构和流上所定义的操作决定了Spliterator的特性，在使用并行流时需要额外注意。比如基于数组的ArrayList要比基于链表的LinkedList易于拆分处理，但如果使用并行流往ArrayList里添加数据的话就会出问题，因为ArrayList不是线程安全的。</p>
<blockquote>
<p>并行流内部使用了默认的ForkJoinPool，默认的线程数为处理器（核心）的数量，这个值由Runtime.getRuntime().availableProcessors()得到，且可以通过系统属性 java.util.concurrent.ForkJoinPool.common.parallelism 来改变线程池大小，如下所示，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.setProperty(<span class="string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span>, <span class="string">"12"</span>);</div></pre></td></tr></table></figure></p>
<p>需注意，这是一个全局变量，因此它将影响代码中所有的并行流。目前还无法专为某个并行流指定这个值，且无法为某个并行流指定特定的线程池。这意味着如果你代码中的某处并行流执行了某些比较耗时的操作，会影响其它地方并行流的性能，且不易发现。<br>一般而言，让ForkJoinPool等于处理器数量是个不错的默认值，除非有很好的理由，否则强烈建议不要修改。</p>
</blockquote>
<h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><p>并不是所有的集合操作都适合并行流，且一般而言，想给出任何关于什么时候该用并行流的定量建议都是不可能也是毫无意义的。通常并行流的使用需要考虑以下几个方面，</p>
<ul>
<li>如果不确定，测量。并行流并不一定总是比顺序流快，如果不确定并行流的引入是否会带来性能上的提升，建议用适当的基准测试来检查其性能。</li>
<li>留意装箱。自动装箱和拆箱会大大降低性能，Java8中有原始类型流来避免这种操作，但凡有可能都应该是使用这些流。</li>
<li>有些操作本身在并行流上的性能就比顺序流差。特别是limit和findFirst等依赖于元素顺序的操作，它们在并行流上执行的代价非常大。</li>
<li>要考虑才做流水线的总计算成本。设<em>N</em>是要处理的元素的个数，<em>Q</em>是一个元素通过流水线的大致处理成本，则<em>N</em> * <em>Q</em>就是对成本的一个粗略的定性估计。<em>Q</em>值较高就意味着使用并行流的性能好的可能性比较大。</li>
<li>对于较小的数据量，选择并行流几乎永远都不是一个好的决定。</li>
<li>考虑背后的数据源的结构是否易于分解。例如基于数据的结构的拆分效率要远高于基于链表的结构，因为前者不用遍历就可以平均拆分。</li>
<li>考虑线程安全性。</li>
<li>流自身的特点，以及流水线中的中间操作修改流的方式，都有可能会改变分解过程的性能。例如，一个SIZED流可以分成大小相等的两部分，这样每部分都可以比较搞笑地并行处理，但filter操作可能丢弃的元素个数却无法预测，这导致流本身的大小未知。</li>
<li>考虑终端操作中合并步骤的代价是大是小（如Collector中的combiner方法）。如果这一步代价很大，那么组合每个子流的部分结果所付出的代价就可能会超过通过并行流得到的性能提升</li>
<li>还要注意，一个JVM进程中的所有并行流使用的是同一个共享的ForkJoinPool，如果一个并行流中的任务比较耗时则可能会间接地影响其它并行流的性能，而这往往很难察觉。</li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>关于stream api的源码分析推荐这篇博文 <a href="https://yq.aliyun.com/articles/69158?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">一起爪哇Java 8（三）——好用的Stream</a></p>
<p>这里我们尝试自己实现一个简易的流处理框架 – MyStream</p>
<p>首先，参考Java8 stream api的使用方式，MyStream的客户端使用如下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStreamApi</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String[] stringArr = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"123"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"45"</span>&#125;;</div><div class="line">        MyList&lt;String&gt; stringList = <span class="keyword">new</span> MyList&lt;&gt;();</div><div class="line">        stringList.addAll(Arrays.asList(stringArr));</div><div class="line"></div><div class="line">        String result = stringList.myStream()</div><div class="line">                .filter(s -&gt; s.length() == <span class="number">1</span>)</div><div class="line">                .map(String::toUpperCase)</div><div class="line">                .reduce((a, b) -&gt; a + b);</div><div class="line"></div><div class="line">        System.out.println(result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们定义了一个字符串数组并add到MyList中，MyList是我们自己定义的一个继承于ArrayList的列表，其myStream()函数用于构造一个流，且能够在流上定义filter、map中间操作，终止操作reduce会触发流的遍历执行。为了方便演示，我们假定字符串数组中的字符长度大于1的都是数字，而等于1的都是小写的单个字母，如此我们希望能filter出原始数组中的字母并将其map成大写字母，最后reduce拼接成一个字符串，即”ABCD”。</p>
<p>先定义MyStream接口和用到的三个函数式接口，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyStream</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">MyStream&lt;T&gt; <span class="title">filter</span><span class="params">(Filter&lt;T&gt; filter)</span></span>;</div><div class="line">    <span class="function">MyStream&lt;T&gt; <span class="title">map</span><span class="params">(Mapper&lt;T&gt; mapper)</span></span>;</div><div class="line">    <span class="function">T <span class="title">reduce</span><span class="params">(Reducer&lt;T&gt; reducer)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Filter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">apply</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Reducer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">apply</span><span class="params">(T t1, T t2)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里为了不引入过多的泛型编程的复杂性，定义Mapper和Reducer的接收和处理返回为同一类型。</p>
<p>MyList的定义如下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Streamable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">MyStream&lt;T&gt; <span class="title">myStream</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Streamable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MyStream&lt;T&gt; <span class="title">myStream</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// todo 定义并返回流</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于在定义流的中间操作filter和map时，并不会触发流的遍历，而终止操作reduce会使得数据源中的每个元素迭代执行已定义好的filter和map操作，由此不难想到可以用链表实现流的构建和每个元素的执行过程。具体的，在myStream函数中定义链表的head节点，MyStream的filter和map函数定义该节点对于元素的过滤和映射逻辑，并连接到当前的链表，MyStream的reduce函数定义链表的tail节点，定义到这一步的元素的规约操作，并能够返回到链表的head节点，启动整个流中的元素依照所定义的迭代方式在这条构建好的流水线上遍历执行。</p>
<p>定义节点，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Sink</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    Sink&lt;T&gt; source;         </div><div class="line">    Sink&lt;T&gt; downstream;</div><div class="line">    T result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>每个节点都持有head节点的引用source和指向下个节点的引用downstream，同时tail节点需要有一个域保存计算结果result。如此便可以构造整个流水线Pipeline，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pipeline</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">MyStream</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Sink&lt;T&gt; upstreamSink;</div><div class="line">    <span class="keyword">private</span> Iterator&lt;T&gt; iterator;   <span class="comment">// 原始数据源的迭代器</span></div><div class="line"></div><div class="line">    <span class="comment">// 定义链表的连接操作</span></div><div class="line">    Pipeline(Pipeline&lt;T&gt; upstream, Sink&lt;T&gt; upstreamSink) &#123;</div><div class="line">        <span class="keyword">this</span>.upstreamSink = upstreamSink;</div><div class="line">        <span class="keyword">if</span> (upstream != <span class="keyword">null</span>) &#123;</div><div class="line">            upstream.upstreamSink.downstream = upstreamSink;</div><div class="line">            <span class="keyword">this</span>.upstreamSink.source = upstream.upstreamSink.source;</div><div class="line">            <span class="keyword">this</span>.iterator = upstream.iterator;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Pipeline(Pipeline&lt;T&gt; upstream, Sink&lt;T&gt; upstreamSink, Iterator&lt;T&gt; iterator) &#123;</div><div class="line">        <span class="keyword">this</span>(upstream, upstreamSink);</div><div class="line">        <span class="keyword">this</span>.iterator = iterator;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MyStream&lt;T&gt; <span class="title">filter</span><span class="params">(Filter&lt;T&gt; filter)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pipeline&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">new</span> Sink&lt;T&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">                <span class="comment">// 满足filter条件的元素才会进入下一个节点的处理</span></div><div class="line">                <span class="keyword">if</span> (filter.test(t)) &#123;       </div><div class="line">                    downstream.accept(t);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MyStream&lt;T&gt; <span class="title">map</span><span class="params">(Mapper&lt;T&gt; mapper)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pipeline&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">new</span> Sink&lt;T&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">                <span class="comment">// 当前元素经过map处理后再交由下个节点处理</span></div><div class="line">                downstream.accept(mapper.apply(t));     </div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">reduce</span><span class="params">(Reducer&lt;T&gt; reducer)</span> </span>&#123;</div><div class="line">        Sink&lt;T&gt; terminalSink = <span class="keyword">new</span> Sink&lt;T&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">                <span class="comment">// 用当前的计算结果result与当前元素做规约操作，结果仍保存到节点的result</span></div><div class="line">                <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">                    result = t;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                result = reducer.apply(result, t);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="comment">//</span></div><div class="line">        Sink&lt;T&gt; head = <span class="keyword">new</span> Pipeline&lt;&gt;(<span class="keyword">this</span>, terminalSink).upstreamSink.source;  </div><div class="line"></div><div class="line">        <span class="keyword">return</span> evaluate(head);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">evaluate</span><span class="params">(Sink&lt;T&gt; head)</span> </span>&#123;</div><div class="line">        <span class="comment">// 遍历原始数据源的每个元素</span></div><div class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">            T t = iterator.next();</div><div class="line">            <span class="comment">// 对于某一元素t依次执行已定义好的流水线的各个节点的操作，即filter -&gt; map -&gt; reduce</span></div><div class="line">            head.accept(t);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 返回最终结果，即tail节点的result</span></div><div class="line">        <span class="keyword">return</span> findTerminalSink(head).result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Sink&lt;T&gt; <span class="title">findTerminalSink</span><span class="params">(Sink&lt;T&gt; head)</span> </span>&#123;</div><div class="line">        Sink&lt;T&gt; terminal = head;</div><div class="line">        <span class="keyword">while</span> (terminal.downstream != <span class="keyword">null</span>) &#123;</div><div class="line">            terminal = terminal.downstream;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> terminal;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关键的代码都已加了注释，现在只差最后一步，head节点的定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Streamable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MyStream&lt;T&gt; <span class="title">myStream</span><span class="params">()</span> </span>&#123;</div><div class="line">        Sink&lt;T&gt; head = <span class="keyword">new</span> Sink&lt;T&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">                <span class="comment">// 只是简单地将元素交由下一节点处理</span></div><div class="line">                downstream.accept(t);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        head.source = head;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pipeline&lt;&gt;(<span class="keyword">null</span>, head, iterator());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里使用了集合内部的迭代器，默认顺序遍历。当然如果想要实现流的并发，则需要自定义类似Spliterator接口的迭代器，并在evaluate函数中使用Fork/Join框架将负责原始数据不同部分的多个迭代器的处理交由ForkJoinPool中的线程并发执行。</p>
<p>全部代码整理如下，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStreamApi</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String[] stringArr = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"123"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"45"</span>&#125;;</div><div class="line">        MyList&lt;String&gt; stringList = <span class="keyword">new</span> MyList&lt;&gt;();</div><div class="line">        stringList.addAll(Arrays.asList(stringArr));</div><div class="line"></div><div class="line">        String result = stringList.myStream()</div><div class="line">                .filter(s -&gt; s.length() == <span class="number">1</span>)</div><div class="line">                .map(String::toUpperCase)</div><div class="line">                .reduce((a, b) -&gt; a + b);</div><div class="line"></div><div class="line">        System.out.println(result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyStream</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">MyStream&lt;T&gt; <span class="title">filter</span><span class="params">(Filter&lt;T&gt; filter)</span></span>;</div><div class="line">    <span class="function">MyStream&lt;T&gt; <span class="title">map</span><span class="params">(Mapper&lt;T&gt; mapper)</span></span>;</div><div class="line">    <span class="function">T <span class="title">reduce</span><span class="params">(Reducer&lt;T&gt; reducer)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pipeline</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">MyStream</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Sink&lt;T&gt; upstreamSink;</div><div class="line">    <span class="keyword">private</span> Iterator&lt;T&gt; iterator;</div><div class="line"></div><div class="line">    Pipeline(Pipeline&lt;T&gt; upstream, Sink&lt;T&gt; upstreamSink) &#123;</div><div class="line">        <span class="keyword">this</span>.upstreamSink = upstreamSink;</div><div class="line">        <span class="keyword">if</span> (upstream != <span class="keyword">null</span>) &#123;</div><div class="line">            upstream.upstreamSink.downstream = upstreamSink;</div><div class="line">            <span class="keyword">this</span>.upstreamSink.source = upstream.upstreamSink.source;</div><div class="line">            <span class="keyword">this</span>.iterator = upstream.iterator;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Pipeline(Pipeline&lt;T&gt; upstream, Sink&lt;T&gt; upstreamSink, Iterator&lt;T&gt; iterator) &#123;</div><div class="line">        <span class="keyword">this</span>(upstream, upstreamSink);</div><div class="line">        <span class="keyword">this</span>.iterator = iterator;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MyStream&lt;T&gt; <span class="title">filter</span><span class="params">(Filter&lt;T&gt; filter)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pipeline&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">new</span> Sink&lt;T&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span> (filter.test(t)) &#123;</div><div class="line">                    downstream.accept(t);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MyStream&lt;T&gt; <span class="title">map</span><span class="params">(Mapper&lt;T&gt; mapper)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pipeline&lt;&gt;(<span class="keyword">this</span>, <span class="keyword">new</span> Sink&lt;T&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">                downstream.accept(mapper.apply(t));</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">reduce</span><span class="params">(Reducer&lt;T&gt; reducer)</span> </span>&#123;</div><div class="line">        Sink&lt;T&gt; terminalSink = <span class="keyword">new</span> Sink&lt;T&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">                    result = t;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                result = reducer.apply(result, t);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        Sink&lt;T&gt; head = <span class="keyword">new</span> Pipeline&lt;&gt;(<span class="keyword">this</span>, terminalSink).upstreamSink.source;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> evaluate(head);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">evaluate</span><span class="params">(Sink&lt;T&gt; head)</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">            T t = iterator.next();</div><div class="line">            head.accept(t);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> findTerminalSink(head).result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Sink&lt;T&gt; <span class="title">findTerminalSink</span><span class="params">(Sink&lt;T&gt; head)</span> </span>&#123;</div><div class="line">        Sink&lt;T&gt; terminal = head;</div><div class="line">        <span class="keyword">while</span> (terminal.downstream != <span class="keyword">null</span>) &#123;</div><div class="line">            terminal = terminal.downstream;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> terminal;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Sink</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    Sink&lt;T&gt; source;</div><div class="line">    Sink&lt;T&gt; downstream;</div><div class="line">    T result;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Filter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">apply</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Reducer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">apply</span><span class="params">(T t1, T t2)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Streamable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">MyStream&lt;T&gt; <span class="title">myStream</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Streamable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> MyStream&lt;T&gt; <span class="title">myStream</span><span class="params">()</span> </span>&#123;</div><div class="line">        Sink&lt;T&gt; head = <span class="keyword">new</span> Sink&lt;T&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">                downstream.accept(t);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        head.source = head;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pipeline&lt;&gt;(<span class="keyword">null</span>, head, iterator());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java8的stream框架的处理思路与此大致相同。当然由于支持了前面所讲的各种特性，整体的复杂性就是另一个量级了。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/java-8-lambda/" rel="next" title="Java 8 Lambda表达式的一点研究">
                <i class="fa fa-chevron-left"></i> Java 8 Lambda表达式的一点研究
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">张冲</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#告别for循环"><span class="nav-number">1.</span> <span class="nav-text">告别for循环</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#流"><span class="nav-number">2.</span> <span class="nav-text">流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#流是什么"><span class="nav-number">2.1.</span> <span class="nav-text">流是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流的使用"><span class="nav-number">2.2.</span> <span class="nav-text">流的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造"><span class="nav-number">2.2.1.</span> <span class="nav-text">构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作"><span class="nav-number">2.2.2.</span> <span class="nav-text">操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#并行流"><span class="nav-number">3.</span> <span class="nav-text">并行流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用"><span class="nav-number">3.1.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原理"><span class="nav-number">3.2.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Fork-Join框架"><span class="nav-number">3.2.1.</span> <span class="nav-text">Fork/Join框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#定义任务"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">定义任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#执行任务"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">执行任务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工作窃取"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">工作窃取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最佳实践"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">最佳实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spliterator"><span class="nav-number">3.2.2.</span> <span class="nav-text">Spliterator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#限制"><span class="nav-number">3.3.</span> <span class="nav-text">限制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实现"><span class="nav-number">4.</span> <span class="nav-text">实现</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张冲</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  









<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  

  

  

</body>
</html>
